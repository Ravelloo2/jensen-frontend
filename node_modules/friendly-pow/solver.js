import { blake2bResetForShortMessage, blake2bCompress, Context } from "./blake2b/blake2b";
import { CHALLENGE_SIZE_BYTES } from "./constants";
export const HASH_SIZE_BYTES = 32;
/**
 * Solve the blake2b hashing problem, re-using the memory between different attempts (which solves up to 50% faster).
 *
 * This only changes the last 4 bytes of the input array to find a solution. To find multiple solutions
 * one could call this function multiple times with the 4 bytes in front of those last 4 bytes varying.
 *
 *
 * The goal is to find a nonce that, hashed together with the rest of the input header, has a value of its
 * most significant 32bits that is below some threshold.
 * Approximately this means: the hash value of it starts with K zeroes (little endian), which is expected to be
 * increasingly difficult as K increases.
 *
 * In practice you should ask the client to solve multiple (easier) puzzles which should reduce variance and also allows us
 * to show a progress bar.
 * @param input challenge bytes
 * @param threshold u32 value under which the solution's hash should be below.
 */
export function solveBlake2bEfficient(input, threshold, n) {
    if (input.length != CHALLENGE_SIZE_BYTES) {
        throw Error("Invalid input");
    }
    const buf = input.buffer;
    const view = new DataView(buf);
    const ctx = new Context(HASH_SIZE_BYTES);
    ctx.t = CHALLENGE_SIZE_BYTES;
    const start = view.getUint32(124, true);
    const end = start + n;
    for (let i = start; i < end; i++) {
        view.setUint32(124, i, true);
        blake2bResetForShortMessage(ctx, input);
        blake2bCompress(ctx, true);
        if ((ctx.h[0]) < threshold) {
            if (ASC_TARGET == 0) { // JS
                return new Uint8Array(ctx.h.buffer);
            }
            //@ts-ignore
            return Uint8Array.wrap(ctx.h.buffer);
        }
    }
    return new Uint8Array(0);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29sdmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3NvbHZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsMkJBQTJCLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzFGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUVuRCxNQUFNLENBQUMsTUFBTSxlQUFlLEdBQUcsRUFBRSxDQUFDO0FBRWxDOzs7Ozs7Ozs7Ozs7Ozs7O0dBZ0JHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUFDLEtBQWlCLEVBQUUsU0FBYyxFQUFFLENBQU07SUFDM0UsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLG9CQUFvQixFQUFFO1FBQ3RDLE1BQU0sS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQ2hDO0lBRUQsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztJQUN6QixNQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUUvQixNQUFNLEdBQUcsR0FBRyxJQUFJLE9BQU8sQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUN6QyxHQUFHLENBQUMsQ0FBQyxHQUFHLG9CQUFvQixDQUFDO0lBRTdCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hDLE1BQU0sR0FBRyxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7SUFFdEIsS0FBSSxJQUFJLENBQUMsR0FBUSxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFN0IsMkJBQTJCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3hDLGVBQWUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFM0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxTQUFTLEVBQUU7WUFDeEIsSUFBSSxVQUFVLElBQUksQ0FBQyxFQUFFLEVBQUUsS0FBSztnQkFDeEIsT0FBTyxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3ZDO1lBQ0QsWUFBWTtZQUNaLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBRXhDO0tBQ0o7SUFFRCxPQUFPLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBibGFrZTJiUmVzZXRGb3JTaG9ydE1lc3NhZ2UsIGJsYWtlMmJDb21wcmVzcywgQ29udGV4dCB9IGZyb20gXCIuL2JsYWtlMmIvYmxha2UyYlwiO1xyXG5pbXBvcnQgeyBDSEFMTEVOR0VfU0laRV9CWVRFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IEhBU0hfU0laRV9CWVRFUyA9IDMyO1xyXG5cclxuLyoqXHJcbiAqIFNvbHZlIHRoZSBibGFrZTJiIGhhc2hpbmcgcHJvYmxlbSwgcmUtdXNpbmcgdGhlIG1lbW9yeSBiZXR3ZWVuIGRpZmZlcmVudCBhdHRlbXB0cyAod2hpY2ggc29sdmVzIHVwIHRvIDUwJSBmYXN0ZXIpLlxyXG4gKiBcclxuICogVGhpcyBvbmx5IGNoYW5nZXMgdGhlIGxhc3QgNCBieXRlcyBvZiB0aGUgaW5wdXQgYXJyYXkgdG8gZmluZCBhIHNvbHV0aW9uLiBUbyBmaW5kIG11bHRpcGxlIHNvbHV0aW9uc1xyXG4gKiBvbmUgY291bGQgY2FsbCB0aGlzIGZ1bmN0aW9uIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlIDQgYnl0ZXMgaW4gZnJvbnQgb2YgdGhvc2UgbGFzdCA0IGJ5dGVzIHZhcnlpbmcuXHJcbiAqIFxyXG4gKiBcclxuICogVGhlIGdvYWwgaXMgdG8gZmluZCBhIG5vbmNlIHRoYXQsIGhhc2hlZCB0b2dldGhlciB3aXRoIHRoZSByZXN0IG9mIHRoZSBpbnB1dCBoZWFkZXIsIGhhcyBhIHZhbHVlIG9mIGl0c1xyXG4gKiBtb3N0IHNpZ25pZmljYW50IDMyYml0cyB0aGF0IGlzIGJlbG93IHNvbWUgdGhyZXNob2xkLlxyXG4gKiBBcHByb3hpbWF0ZWx5IHRoaXMgbWVhbnM6IHRoZSBoYXNoIHZhbHVlIG9mIGl0IHN0YXJ0cyB3aXRoIEsgemVyb2VzIChsaXR0bGUgZW5kaWFuKSwgd2hpY2ggaXMgZXhwZWN0ZWQgdG8gYmVcclxuICogaW5jcmVhc2luZ2x5IGRpZmZpY3VsdCBhcyBLIGluY3JlYXNlcy5cclxuICogXHJcbiAqIEluIHByYWN0aWNlIHlvdSBzaG91bGQgYXNrIHRoZSBjbGllbnQgdG8gc29sdmUgbXVsdGlwbGUgKGVhc2llcikgcHV6emxlcyB3aGljaCBzaG91bGQgcmVkdWNlIHZhcmlhbmNlIGFuZCBhbHNvIGFsbG93cyB1c1xyXG4gKiB0byBzaG93IGEgcHJvZ3Jlc3MgYmFyLlxyXG4gKiBAcGFyYW0gaW5wdXQgY2hhbGxlbmdlIGJ5dGVzXHJcbiAqIEBwYXJhbSB0aHJlc2hvbGQgdTMyIHZhbHVlIHVuZGVyIHdoaWNoIHRoZSBzb2x1dGlvbidzIGhhc2ggc2hvdWxkIGJlIGJlbG93LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlQmxha2UyYkVmZmljaWVudChpbnB1dDogVWludDhBcnJheSwgdGhyZXNob2xkOiB1MzIsIG46IHUzMik6IFVpbnQ4QXJyYXkge1xyXG4gICAgaWYgKGlucHV0Lmxlbmd0aCAhPSBDSEFMTEVOR0VfU0laRV9CWVRFUykge1xyXG4gICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBpbnB1dFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWYgPSBpbnB1dC5idWZmZXI7XHJcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1Zik7XHJcblxyXG4gICAgY29uc3QgY3R4ID0gbmV3IENvbnRleHQoSEFTSF9TSVpFX0JZVEVTKTtcclxuICAgIGN0eC50ID0gQ0hBTExFTkdFX1NJWkVfQllURVM7XHJcblxyXG4gICAgY29uc3Qgc3RhcnQgPSB2aWV3LmdldFVpbnQzMigxMjQsIHRydWUpO1xyXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBuO1xyXG5cclxuICAgIGZvcihsZXQgaTogdTMyID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xyXG4gICAgICAgIHZpZXcuc2V0VWludDMyKDEyNCwgaSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIGJsYWtlMmJSZXNldEZvclNob3J0TWVzc2FnZShjdHgsIGlucHV0KTtcclxuICAgICAgICBibGFrZTJiQ29tcHJlc3MoY3R4LCB0cnVlKTtcclxuXHJcbiAgICAgICAgaWYgKChjdHguaFswXSkgPCB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgaWYgKEFTQ19UQVJHRVQgPT0gMCkgeyAvLyBKU1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGN0eC5oLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9AdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LndyYXAoY3R4LmguYnVmZmVyKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcclxufVxyXG4iXX0=